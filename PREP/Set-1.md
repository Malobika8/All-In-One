## JPA vs Hibernate ‚Äì What, Why, How

### üîπ **What is JPA?**

> JPA (Java Persistence API) is a **Java specification** for ORM (Object Relational Mapping).
> It provides **standard annotations and interfaces** to manage relational data in Java applications.

* It is **just an API** ‚Äî not an implementation.
* Think of it as the **rules**.

### üîπ **What is Hibernate?**

> Hibernate is the **most popular implementation** of the JPA specification.
> It provides extra features beyond JPA, like:

* Caching
* Custom query language (HQL)
* Advanced mappings

### üîπ **How they relate:**

* You code using **JPA annotations** (`@Entity`, `@Id`, etc.)
* At runtime, Hibernate executes the logic **under the hood**.
* Other JPA implementations: EclipseLink, OpenJPA

### ‚úÖ Example:

```java
@Entity
public class User {
    @Id
    private Long id;

    private String name;
}
```

This is **pure JPA**, but Hibernate will implement it during execution.

---

# What is the difference between JPA and Hibernate?**

### Sol:

> **JPA (Java Persistence API)** is a **specification** provided by Java to standardize how Java objects are mapped to relational databases. It defines a set of **annotations, interfaces, and contracts** but doesn't provide the actual implementation.

> **Hibernate** is the **most popular implementation** of the JPA specification. It provides the actual logic to persist, update, delete, and query entities. Hibernate also offers additional features like:

* HQL (Hibernate Query Language)
* First- and Second-Level Caching
* Dirty Checking
* Schema generation, etc.

> So, you **write code using JPA**, but **Hibernate performs the work behind the scenes**.

---

# What is an Entity in JPA? What annotations are required to define an Entity? Also write a basic `User` entity with `id`, `name`, and `email`.

### Sol:

> In JPA, an **Entity** is a Java class that is **mapped to a table** in the relational database.
> Each instance of the entity represents a row in the table.

#### Requirements to make a class a JPA Entity:

1. Must be annotated with `@Entity`
2. Must have a **no-argument constructor** (can be `public` or `protected`)
3. Must have a **primary key** field annotated with `@Id`
4. Should be a **non-final** class and follow JavaBean conventions

```java
import jakarta.persistence.Entity;
import jakarta.persistence.Id;

@Entity
public class User {

    @Id
    private int id;

    private String name;
    private String email;

    // Required no-arg constructor
    public User() {}

    // Optionally, you can add constructors and getters/setters
}
```

#### Notes:

* `@Id`** is **mandatory** to define the **primary key**
* The class should be `public`
* Having a no-arg constructor is a **requirement** for JPA
* `@Entity` alone doesn‚Äôt create a table ‚Äî it's just the mapping layer

---

# What is the use of `@Id` and `@GeneratedValue`? Write a `User` entity where:

* `id` is autogenerated
* Table name is `users`
* Columns are: `id`, `name`, `email` (with custom column name `user_email`)

### Sol:

> `@Id` is used to mark a field as the **primary key** of the entity.
> `@GeneratedValue` is used to specify how the primary key should be **automatically generated**.
   Common strategies include:
   * `AUTO`: Let JPA provider (e.g., Hibernate) decide
   * `IDENTITY`: Use auto-increment column in DB
   * `SEQUENCE`: Use a database sequence
   * `TABLE`: Use a separate table to generate values

```java
import jakarta.persistence.*;

@Entity
@Table(name = "users")
@NoArgsConstructor
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private int id;

    private String name;

    @Column(name = "user_email")
    private String email;
}
```

---

# What is the difference between `@Column`, `@Table`, and `@Entity`?

### Sol:

#### `@Entity`

* Marks a Java class as a **JPA Entity** (i.e., it maps to a DB table).
* Required for any class you want JPA/Hibernate to persist.
* Does **not take a table name** as a parameter.

```java
@Entity
public class User { ... }
```

#### `@Table(name = "table_name")`

* Optional annotation that specifies the **name of the table** in the database.
* Without this, JPA will map the class name (e.g., `User`) to a table of the **same name** (case-sensitive in some DBs).

```java
@Entity
@Table(name = "users")
public class User { ... }
```

#### `@Column(name = "column_name")`

* Optional annotation used to **map a field to a specific column name** in the table.
* Also lets you customize properties like:

  * `nullable`
  * `length`
  * `unique`
  * `insertable` / `updatable`

```java
@Column(name = "user_email", nullable = false, length = 100)
private String email;
```

#### Summary Table:

| Annotation | Purpose                                          |
| ---------- | ------------------------------------------------ |
| `@Entity`  | Marks the class as a persistent JPA entity       |
| `@Table`   | Maps the entity to a specific table in DB        |
| `@Column`  | Maps the field to a specific column in the table |

---

# What is the difference between JPQL and HQL? And when do we use them?

### Sol:

#### Difference between JPQL and HQL?**

> **JPQL (Java Persistence Query Language)** is the official **object-oriented query language defined by the JPA specification**.
> It allows you to query entities using **entity names and property names**, **not table or column names**.
> Since it's part of the JPA standard, it's **portable across all JPA implementations** (like Hibernate, EclipseLink, etc.).

> **HQL (Hibernate Query Language)** is a **Hibernate-specific extension** of JPQL.
> It looks and feels similar to JPQL but includes **Hibernate-only features** that **may not be portable** to other JPA providers.

#### Key Differences:

| Feature                      | JPQL            | HQL                                                   |
| ---------------------------- | --------------- | ----------------------------------------------------- |
| Defined by                   | JPA spec        | Hibernate                                             |
| Portable                     | ‚úÖ Yes           | ‚ùå No                                                  |
| Syntax                       | Entity-based    | Entity-based                                          |
| Extra Features               | ‚ùå Standard only | ‚úÖ Some Hibernate-specific (e.g., `insert ... select`) |
| Recommended in JPA projects? | ‚úÖ Yes           | Only if you're Hibernate-specific                     |

#### JPQL Example:

```java
// Select all users
TypedQuery<User> query = em.createQuery("SELECT u FROM User u", User.class);
List<User> users = query.getResultList();
```

> This queries based on the **User entity** (not the `users` table) and its fields.

---

# What are the types of relationships in JPA? Please name the main types (4 total) and explain when each is used.

### Sol:

Types of Relationships in JPA (with Real Examples)

#### 1. `@OneToOne`

> One entity is associated with exactly one other entity.

**Example:**

A `User` has one `Profile`.

```java
@Entity
public class User {
    @Id
    private int id;

    @OneToOne
    private Profile profile;
}
```

#### 2. `@OneToMany`

> One entity is related to **many instances** of another entity.

**Example:**

A `Department` has many `Employee`s.

```java
@Entity
public class Department {
    @Id
    private int id;

    @OneToMany(mappedBy = "department")
    private List<Employee> employees;
}
```

#### 3. `@ManyToOne`

> Many entities are associated with one parent entity.

**Example:**

Many `Employee`s belong to one `Department`.

```java
@Entity
public class Employee {
    @Id
    private int id;

    @ManyToOne
    private Department department;
}
```

#### 4. `@ManyToMany`

> Many instances of one entity are related to many instances of another.

**Example:**

A `Student` can enroll in many `Course`s, and a `Course` can have many `Student`s.

```java
@Entity
public class Student {
    @Id
    private int id;

    @ManyToMany
    private List<Course> courses;
}
```

#### Summary Table

| Annotation    | Description             | Example                |
| ------------- | ----------------------- | ---------------------- |
| `@OneToOne`   | One-to-one relationship | User ‚Üí Profile         |
| `@OneToMany`  | One to many             | Department ‚Üí Employees |
| `@ManyToOne`  | Many to one             | Employee ‚Üí Department  |
| `@ManyToMany` | Many to many            | Student ‚Üî Course       |

---

# Code Exercise ‚Äì Model a Department and Employee using `@OneToMany` and `@ManyToOne`?

### Sol:

#### `Department.java`

```java
import jakarta.persistence.*;
import java.util.List;

@Entity
@NoArgsConstructor
public class Department {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private int dId;

    private String dName;

    @OneToMany(mappedBy = "department", cascade = CascadeType.ALL)
    private List<Employee> employees;

    // Getters and Setters (optional if using Lombok)
}
```

#### `Employee.java`

```java
import jakarta.persistence.*;

@Entity
@NoArgsConstructor
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private int id;

    private String name;

    @ManyToOne
    @JoinColumn(name = "department_id")  // Optional: customize FK column name
    private Department department;

    // Getters and Setters
}
```

| Good Practice               | Why it's good                                                               |
| --------------------------- | --------------------------------------------------------------------------- |
| `mappedBy="department"`     | Tells JPA that **Department doesn't own the relationship**, `Employee` does |
| `@JoinColumn(name="...")`   | Clarifies foreign key column name                                           |
| `cascade = CascadeType.ALL` | Makes saving departments auto-save their employees (optional but common)    |
| `@NoArgsConstructor`        | JPA requires a no-arg constructor                                           |

---

# What is the difference between `mappedBy` and `@JoinColumn`? Who owns the relationship?

### Sol:

#### üîπ `@JoinColumn`

* Used on the **owning side** of the relationship.
* It specifies the **foreign key column name** in the database table.
* By default, JPA generates a column like `department_id` in the `Employee` table.

```java
@ManyToOne
@JoinColumn(name = "department_id")
private Department department;
```

#### üîπ `mappedBy`

* Used on the **inverse side (non-owning side)** of the relationship.
* It tells JPA that **this entity doesn't manage the relationship**.
* The value of `mappedBy` should match the name of the field in the owning entity.

```java
@OneToMany(mappedBy = "department")
private List<Employee> employees;
```

#### Ownership Summary:

| Annotation    | Used In                              | Means                                |
| ------------- | ------------------------------------ | ------------------------------------ |
| `@JoinColumn` | Owning side (typically `@ManyToOne`) | "I control the foreign key column"   |
| `mappedBy`    | Inverse side (`@OneToMany`)          | "The other entity owns the relation" |

> If both sides try to own the relationship (i.e., both have `@JoinColumn`), JPA will throw an error.

---

# What is the difference between FetchType.LAZY and FetchType.EAGER?

### Sol:

#### üîπ `FetchType.LAZY`

> Associated data is **not loaded immediately** with the parent entity.
> Instead, a **proxy** is returned, and the data is fetched **only when accessed**.

#### üîπ `FetchType.EAGER`

> Associated data is **loaded immediately** with the parent entity, **regardless of whether it's needed**.

#### Real-World Example:

Let‚Äôs say a `Department` has many `Employee`s.

```java
@OneToMany(mappedBy = "department", fetch = FetchType.LAZY)
private List<Employee> employees;
```

When you do:

```java
Department dept = entityManager.find(Department.class, 1);
```

* With `LAZY`: only department data is fetched. Employees are fetched **later**, if/when you access `dept.getEmployees()`.
* With `EAGER`: department and **all its employees** are fetched **together**, even if you don‚Äôt need them.

#### ‚ö†Ô∏è Important Defaults to Remember:

| Relationship  | Default Fetch Type |
| ------------- | ------------------ |
| `@OneToMany`  | `LAZY` ‚ùó           |
| `@ManyToOne`  | `EAGER` ‚úÖ          |
| `@OneToOne`   | `EAGER` ‚úÖ          |
| `@ManyToMany` | `LAZY` ‚ùó           |

#### Note:

If you EAGER-fetch a collection with 1000 children, it can **destroy performance**.
**Use `LAZY` by default**, and manually fetch relationships only when needed.

---

